input {
  # General webhook endpoint
  http {
    port => 8081
    type => "webhook"
    tags => ["webhook"]
  }
  
  # Specific endpoint for alerts
  http {
    port => 8082
    type => "alert_webhook"
    tags => ["webhook", "alert"]
  }
}

filter {
  # Parse webhook payload
  if [type] == "webhook" {
    json {
      source => "message"
      target => "payload"
    }
  }
  
  # Validate webhook signature (security)
  if [headers][x-webhook-signature] {
    ruby {
      code => "
        require 'openssl'
        signature = event.get('[headers][x-webhook-signature]')
        payload = event.get('message')
        secret = ENV['WEBHOOK_SECRET']
        
        if signature && payload && secret
          expected = 'sha256=' + OpenSSL::HMAC.hexdigest('sha256', secret, payload)
          if signature != expected
            event.tag('invalid_signature')
          end
        end
      "
    }
  }
  
  # Route webhook by type
  if [payload][type] == "price_alert" {
    mutate {
      add_tag => ["price_alert"]
      add_field => { "alert_type" => "price" }
    }
  }
  
  if [payload][type] == "news_alert" {
    mutate {
      add_tag => ["news_alert"]
      add_field => { "alert_type" => "news" }
    }
  }
  
  # Add processing metadata
  mutate {
    add_field => { "ingested_at" => "%{@timestamp}" }
    add_field => { "data_type" => "webhook" }
  }
}

output {
  # Route to appropriate Kafka topic
  if "price_alert" in [tags] {
    kafka {
      topic_id => "price-alerts"
      bootstrap_servers => "kafka:9092"
      codec => json
    }
  }
  
  if "news_alert" in [tags] {
    kafka {
      topic_id => "news-alerts"
      bootstrap_servers => "kafka:9092"
      codec => json
    }
  }
  
  # Index all webhooks
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "webhooks-%{+YYYY.MM.dd}"
    document_type => "_doc"
  }
}